
import json

class MalwareSample:
    def __init__(self, raw_object):
        self.raw_object = raw_object


    def _get_deepest_lvl(self, tree):
        """
            Calculates the deepest level on the process tree:

            Arguments:
            `tree`: the root of the tree.
        """
        if not tree.has_key('children'):
            return 0
        else:
            ans = 0
            for r in tree['children']:
                ans  = max(ans, 1 + self._get_deepest_lvl(r))
            return ans

    def _get_interaction_counts(self, enhanced):
        """
            Extracts the amount of reads, writes and executes
            from the enhanced attribute in the json file.

            Arguments:
            `enhanced`: The dict that contains the log of the actions

            retuns the counts for read, write, load in that order
        """
        from collections import defaultdict
        op_count = defaultdict(int)
        for l in enhanced:
            op_count[l['event']] += 1

        return op_count

    def _populate_fields(self):
        """
            Parse the raw json object extracting any features
            we want.
        """
        # First we start with network 
        ro = self.raw_object['network']
        self.udp_count = len(ro.get('udp', []))
        self.irc_count = len(ro.get('irc', []))
        self.http_count = len(ro.get('http', []))
        self.smtp_count = len(ro.get('smtp', []))
        self.tcp_count = len(ro.get('tcp', []))

        # Then from info
        ro = self.raw_object['info']
        self.duration = ro.get('duration', 0)

        # Then from target
        ro = self.raw_object['target']
        self.size = ro.get('size', 0)

        # Then from behavior
        ro = self.raw_object['behavior']

        self.number_processes = ro.get('processes', 0)
        self.ptree_depth = max([self._get_deepest_lvl(x) 
                                    for x in ro['processtree']])

        op_count = self._get_interaction_counts(ro['enhanced'])
        print op_count
        for key, value in op_count.items():
            setattr(self, key+'_count', value)

    def save_to_database(self, collection):
        """
            Saves the current object to the database
            that was specified by the `client` connection

            Arguments:
            `collection`: A collection of a document on mongo that
            we will insert into.
        """
        if self.udp_count == None:
            self._populate_fields()

        collection.insert(self.__dict__)
