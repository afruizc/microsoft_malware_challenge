"""
Template code to be used in the
Microsoft Malware Classification challenge.
"""

__authors__ = 'Aaron Gonzales, Andres Ruiz'
__licence__ = 'Apache'
__email__ = 'afruizc@cs.unm.edu'

import sys
import numpy as np

import pymongo
import joblib

from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer
from sklearn.ensemble import RandomForestClassifier
from sklearn.decomposition import TruncatedSVD
from sklearn.grid_search import GridSearchCV

def _init_connection():
    """
    Creates a connection with the mongo database using the
    default parameters and returns the malware database.
    """
    client = pymongo.MongoClient("afruizc-office.cs.unm.edu")
    client.malware.authenticate("populator", "malware_challenge")
    return client.malware

class Executor(object):
    """
    Executes the selected classification pipeline. The executor has a set
    of methods that are intended to be called in certain order. It might
    be the case that this code breaks when some important method
    wasnt called. The methods outlined below are intuitive and not
    very difficult to understand.

    For an example on this order, please refer to the main function.
    """


    def __init__(self):
        """
        Creates a new executor object and initializes the main
        components.
        """
        self.target_names = ['Ramnit', 'Lollipop', 'Kelihos_ver3',
                             'Vundo', 'Simda', 'Tracur', 'Kelihos_ver1',
                             'Obfuscator.ACY', 'Gatak']
        self.db = _init_connection()
        self.train = None
        self.test = None
        self.param_tunning = None
        self.fitted_model = None

    def _load_train(self):
        """
        Loads the training dataset.
        __THIS__ is the method you want to modify when querying
        the database.
        """
        data_train = [('\n'.join(x['ida_comments']), x['class'])
                          for x in self.db.samples.find({
                          "id": {"$exists": True}, # The id field exists
                          "ida_comments ": {"$ne": ""}})]
                            # ^ For non-empty field
        return list(zip(*data_train))

    def _load_test(self):
        """
        Loads the testing dataset.
        __THIS__ is the method you want to modify when querying
        the database.
        """
        data_test = [('\n'.join(x['ida_comments']), '"%s"' % x['id'])
                      for x in self.db.test_samples.find({
                            "id":{"$exists": True}, # The id field exists
                            "ida_comments": {"$ne": ""}})]
        return list(zip(*data_test))

    def load_data(self, training=True, testing=False):
        """
        Fetches the training data from the database. `training` and
        testing indicate the datasets that should be loaded.

        Arguments:
        `training`: If False, the __training__ dataset is NOT loaded.
        `testng`: If True, the __testing__ dataset IS loaded
        """
        if training:
            temp = self._load_train()
            self.train = {'data': temp[0], 'target': temp[1]}
        if testing:
            temp = self._load_test()
            self.test = {'data': temp[0], 'names':temp[1]}

    def config_model(self):
        """
        Configures the pipeline
        """
        pip = Pipeline([
            ('vectorizer', CountVectorizer(max_df=.8, \
                                          ngram_range = (1, 2))),
            ('freq_norm', TfidfTransformer()),
            ('lsa', TruncatedSVD()),
            ('classifier', RandomForestClassifier(n_jobs=-1))
        ])
        parameters = {
        }
        self.param_tunning = GridSearchCV(pip, parameters, n_jobs=4)

    def fit(self):
        """
        Fits the parameters to the pipeline
        """
        self.fitted_model = self.param_tunning.fit(self.train['data'],
                                                   self.train['target'])

    def _predict(self, X, create_submission=False, filename='submission.txt'):
        """
        Predicts a set of 9 probabilities per malware sample, that
        correspond to the 9 malware classes. If `create_submission`
        is True, then a text file named `filename` is created for
        submission into Kaggle.

        Arguments:
        `X`: The data in which predictions will be made.
        `create_submission`: Indicates whether a submission file should
        be created or not.
        `filename`: The file that will contain the submission.
        """
        predicted_prob = self.fitted_model.predict_proba(X)
        if create_submission:
            to_print = np.column_stack((np.array(self.test['names']),
                                        predicted_prob))
            np.savetxt(filename, to_print, header=','.join(['"id"'] + \
                                ['"Prediction%d"' % x for x in range(1, 10)]), \
                                   fmt='%s', delimiter=',')
        return predicted_prob

    def predict_on_test(self, create_submission=False,
                        filename='submission.txt'):
        """
        Performs predicton on the test dataset. see `_predict` for
        the Keyword arguments that can be used.

        Arguments:
        `**kwargs`: see `_predict`.
        """
        if self.test == None:
            sys.stderr.write("Test set not loaded. Aborting prediction\n")
            return
        return self._predict(self.test['data'], create_submission, filename)

    def load_model(self, filename='model.pkl'):
        """
        Attempts to load the already computed model from
        the `filename` file. If it is not found, then raises
        and exception.

        Argmuments:
        `filename`: The name of the file that contains the model
        """
        self.fitted_model = joblib.load(filename)

    def save_model(self, filename='model.pkl'):
        """
        Attempts to save the model into the file indicated by
        `filename`. NOTE: Uses the library joblib
        """
        joblib.dump(self.fitted_model, filename)

def main():
    """
    Runs the main program
    """
    executor = Executor()
    print("Loading data...")
    executor.load_data(testing=True)
    print('Configuring the model...')
    executor.config_model()
    print('Fitting the model...')
    executor.fit()
    print("Saving the model")
    executor.save_model()
    #print("Loading the model")
    #executor.load_model()
    print('Predicting...')
    executor.predict_on_test(create_submission=True)

if __name__ == '__main__':
    main()
